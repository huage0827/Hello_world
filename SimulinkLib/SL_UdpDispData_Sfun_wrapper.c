/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Simulink Coder, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Simulink Coder User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Tue Oct 20 15:43:18 2015
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>

//#include "SL_SimulinkCommDef.h"

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <errno.h>
#include <ifaddrs.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <sys/mman.h>
#include <netinet/in.h>
#include <math.h>
#include "SimulinkModelDef.h"

static int g_CltSocket = -1;
static char g_SvrIpAddr[64] = {0};
static int SL_InitUdpClient();
static int SL_UdpClientSend(const char *szData, int nDataLen, const char *szSvrIp, int svrPort);
static int SL_UdpClientSend2(const double *dValue, int nValLen, const char *szSvrIp, int svrPort);
static int SL_UninitUdpClient();

//////////////// Start
void SL_UdpDispData_Sfun_Start_wrapper(const real_T *u0,
                          real_T *y0,
                          real_T *Error  , 
                          const real_T  *DispType, const int_T  p_width0, 
                          const real_T  *IpPort, const int_T  p_width1, 
                          const real_T  *Timeout,  const int_T p_width2,
			     const int_T y_width, const int_T u_width)
{
	strcpy(g_SvrIpAddr, g_SimuCfg.szMonitorIp);
	SL_InitUdpClient();
}
//////////////// Outputs
void SL_UdpDispData_Sfun_Outputs_wrapper(const real_T *u0,
                          real_T *y0,
                          real_T *Error  , 
                          const real_T  *DispType, const int_T  p_width0, 
                          const real_T  *IpPort, const int_T  p_width1, 
                          const real_T  *Timeout,  const int_T p_width2,
			     const int_T y_width, const int_T u_width)
{
	int nPort = (int)IpPort[0];
	SL_UdpClientSend2(u0, u_width, g_SvrIpAddr, nPort);
}

////////////////
void SL_UdpDispData_Sfun_Terminate_wrapper(const real_T *u0,
                          real_T *y0,
                          real_T *Error  , 
                          const real_T  *DispType, const int_T  p_width0, 
                          const real_T  *IpPort, const int_T  p_width1, 
                          const real_T  *Timeout,  const int_T p_width2,
			     const int_T y_width, const int_T u_width)
{
	SL_UninitUdpClient();
}

int SL_InitUdpClient()
{
	int sock = socket(AF_INET, SOCK_DGRAM, 0);

	g_CltSocket = sock;
	return 0;
}

int SL_UpdClientSend(const char *szData, int nDataLen, const char *szSvrIp, int svrPort)
{
	struct sockaddr_in  sAddr;

	sAddr.sin_family = AF_INET;
	sAddr.sin_addr.s_addr = inet_addr(szSvrIp);
	sAddr.sin_port = htons(svrPort);
	memset(sAddr.sin_zero, 0, 8 * sizeof(char));
	return sendto(g_CltSocket, szData, nDataLen, 0, (struct sockaddr*)&sAddr, sizeof(sAddr));
}

int SL_UdpClientSend2(const double *dValue, int nValLen, const char *szSvrIp, int svrPort)
{
	char szBuf[2048];
	unsigned short ulDataLen = 0;
	int offset = 0;
	int i = 0;
	unsigned int sumCheck = 0;
	struct sockaddr_in  sAddr;

	ulDataLen = 8 * nValLen;
	// Proto Head : 2 byte
	offset = 0;
	szBuf[0] = 0xAB;
	szBuf[1] = 0xCD;

	// Data Len : 2 byte
	offset = 2;
	memcpy(szBuf + offset, &ulDataLen, 2);

	// Data : from 8.
	offset = 8;
	for( i = 0; i < nValLen; i++){
		memcpy(szBuf + offset, &dValue[i], 8);
		offset += 8;
	}

	// calc sum
	sumCheck = 0;
	for( i = 0; i < ulDataLen; i++){
		sumCheck += (unsigned char)szBuf[i+8];
	}

	// sum Check.
	memcpy(szBuf + 4, &sumCheck, 4);

	// send to Data
	sAddr.sin_family = AF_INET;
	sAddr.sin_addr.s_addr = inet_addr(szSvrIp);
	sAddr.sin_port = htons(svrPort);
	memset(sAddr.sin_zero, 0, 8 * sizeof(char));

	return sendto(g_CltSocket, szBuf, offset, 0, (struct sockaddr*)&sAddr, sizeof(sAddr));
}

int SL_UninitUdpClient()
{
	close(g_CltSocket);
	return 0;
}
